#labels Featured
#A full example !

= NAXSI setup howto =

This document describes the full process of configuring NAXSI.

== Installing nginx + naxsi ==

Nginx doesn't support (by design) loadable modules. Extra modules must
be added during compilation. Here we will install it from the source, but (if you're lucky) you might as well find nginx+naxsi already packaged in the download section ;)

{{{
wget http://nginx.org/download/nginx-1.0.11.tar.gz
wget http://naxsi.googlecode.com/files/naxsi-0.42.tar.gz
tar xvzf nginx-1.0.11.tar.gz 
tar xvzf naxsi-0.42.tar.gz
cd nginx-1.0.11/
}}}
`[install libpcre (and libssl if you want https, along with zlib for gzip support) libs with your favorite package manager, naxsi relies on it for regex]`
{{{
./configure --add-module=../naxsi-0.42/naxsi_src/ [add/remove your favorite/usual options]
make
make install
}}}

my personal "building" options being, here :
{{{
./configure --conf-path=/etc/nginx/nginx.conf     --error-log-path=/var/log/nginx/error.log     --http-client-body-temp-path=/var/lib/nginx/body     --http-fastcgi-temp-path=/var/lib/nginx/fastcgi     --http-log-path=/var/log/nginx/access.log     --http-proxy-temp-path=/var/lib/nginx/proxy     --lock-path=/var/lock/nginx.lock     --pid-path=/var/run/nginx.pid     --with-http_ssl_module     --without-mail_pop3_module     --without-mail_smtp_module     --without-mail_imap_module     --without-http_uwsgi_module     --without-http_scgi_module     --with-ipv6     --add-module=../naxsi-0.42/naxsi_src/ --prefix=/usr
}}}

== Important note ==

You need to remember this if you are new to nginx :

NGINX will decide the order of modules according the order of the module's directive in nginx's configuration file. So, no matter what (except you _really_ know what you are doing) *put naxsi's include FIRST in your location*.

If you don't do so, you might run into various problems, from random / unpredictable behaviors to non-effective WAF.


== Initial setup ==
I want to configure NAXSI for my company's website :

www.nbs-system.com

So, let's have a look at the initial setup :

/etc/nginx/nginx.conf :
{{{
user www-data;
worker_processes  1;
worker_rlimit_core  500M;
working_directory   /tmp/;

error_log  /var/log/nginx/error.log;
pid        /var/run/nginx.pid;


events {
    worker_connections  1024;
    use epoll;
    # multi_accept on;                                                                                                                      
}

http {
    include        /etc/nginx/naxsi_core.rules;
    include       /etc/nginx/mime.types;
    server_names_hash_bucket_size 128;
    access_log  /var/log/nginx/access.log;

    sendfile        on;
    keepalive_timeout  65;
    tcp_nodelay        on;

    gzip  on;
    gzip_disable "MSIE [1-6]\.(?!.*SV1)";
    include /etc/nginx/sites-enabled/*;
}
}}}

Notice the /etc/nginx/naxsi_core.rules include. This file is provided in the project (naxsi_config/), and it contains the rules. As you might have noticed, this are not signatures, in the classic WAF sense, but rather "score rules".

Now, let's have a look at my sites-enabled/default :
{{{
server {
 proxy_set_header Proxy-Connection "";
listen       *:80;
access_log  /tmp/nginx_access.log;
error_log  /tmp/nginx_error.log debug;

location / {
     include    /etc/nginx/nbs.rules;
     proxy_pass http://194.213.124.111/;
     proxy_set_header Host www.nbs-system.com;
   }

#This location is where, in learning mode, to-be-forbidden requests will be "copied"
#In non-learning mode, it's where denied request will land, so feel free to do whatever you want, 
#return 418 I'm a teapot, forward to a custom webpage with 
#a captcha to help track false-positives (see contrib for that),
#whatever you want to do !
 location /RequestDenied {
     proxy_pass http://127.0.0.1:4242;
   }
}
}}}


/etc/nginx/nbs.rules :
{{{
LearningMode;
SecRulesEnabled;
#SecRulesDisabled;
DeniedUrl "/RequestDenied";

include "/tmp/naxsi_rules.tmp";

## check rules
CheckRule "$SQL >= 8" BLOCK;
CheckRule "$RFI >= 8" BLOCK;
CheckRule "$TRAVERSAL >= 4" BLOCK;
CheckRule "$EVADE >= 4" BLOCK;
CheckRule "$XSS >= 8" BLOCK;
}}}


/tmp/naxsi_rules.tmp is empty for now, it'll be filled at runtime by the learning daemon (see HttpConfigPy).


Remember the location /RequestDenied in my configuration ? 

Well, let's fire HttpConfigPy so that it'll listen there (127.0.0.1:4242)

{{{
# python http_config.py -h
usage: http_config.py [-h] [--dst DST] [--db DB] [--rules RULES] [--cmd CMD]
                      [--port PORT] [-n] [-v V]

Naxsi's learning-mode HTTP server. Should be run as root (yes scarry), as it
will need to perform /etc/init.d/nginx reload. Should run fine as non-root,
but you'll have to manually restart nginx

optional arguments:
  -h, --help     show this help message and exit
  --dst DST      Full path to the temp rule file. This file should be included
                 in your naxsi's location configuration file. (default:
                 /tmp/naxsi_rules.tmp)
  --db DB        SQLite database file to use. (default: naxsi_tmp.db)
  --rules RULES  Path to your core rules file. (default:
                 /etc/nginx/naxsi_core.rules)
  --cmd CMD      Command that will be called to reload nginx's config file
                 (default: /etc/init.d/nginx reload)
  --port PORT    The port the HTTP server will listen to (default: 4242)
  -n             Run the daemon as non-root, don't try to reload nginx.
                 (default: False)
  -v V           Verbosity level 0-3 (default: 1)

}}}

I'll just stick with the default settings, here we go :
{{{
# python http_config.py -v 3
Finished DB creation.
Starting server, use <Ctrl-C> to stop
}}}

Yes, I launch it as root. Why ? Well, I want my configuration to be easy. By launching the daemon as root, it has the capability to reload nginx by on its own. This is only a facility, and should be done with huge care (here, it'll only listen on 127.0.0.1 so it's kinda ok).

Now we are ready !

To make it clear, I configured nginx as a local reverse proxy for my company's website, and I modified my /etc/hosts file, so that www.nbs-system.com points to 127.0.0.1. In this way, I can configure and test NAXSI without any effect for the other users, I will be the only one impacted.

== Starting the LearningMode phase ==

So I can now fire my browser at www.nbs-system.com, and it will actually hit 127.0.0.1:80, where my nginx+naxsi is waiting for me !

Whenever an exception (false positive) is catched, you see things appear into the HttpConfigPy console. If you want to be sure that your setup is correctly working, just add an attack pattern and see if something is printed in the HttpConfigPy console.

Ok, so I now load the main page of my company's website, browse a bit, and I see a lot of things being displayed in HttpConfigPy console's. This means that there are some false positives, but don't worry, that's ok, even normal !

To see how many, I will just open 127.0.0.1:4242 in my browser to access the HttpConfigPy interface :
{{{
You currently have 5.0 rules generated by naxsi.
You should reload nginx's config WRITE AND RELOAD
You have a total of 5.0 exceptions hit.
Authorizing :
rule 1005(|) authorized on url for argument 'cookie' of zone HEADERS
rule 1010(() authorized on url for argument 'cookie' of zone HEADERS
rule 1011()) authorized on url for argument 'cookie' of zone HEADERS
rule 1308(() authorized on url for argument 'cookie' of zone HEADERS
rule 1309()) authorized on url for argument 'cookie' of zone HEADERS
}}}

It means that a total of 5 request would have been blocked, and 5 rules were generated. Actually, that's (once again) perfectly normal. With no whitelists, I will just click the "WRITE and RELOAD" link. What it will do is :
 * Write the generated rule to /tmp/naxsi_rules.tmp
 * Reload NGINX

After you click the link, the page will display this :
{{{
You currently have 0.0 rules generated by naxsi.
You have a total of 5.0 exceptions hit.
Authorizing :
}}}

Let's have a look at our generated rules :
*This example is deprecated, naxsi core rules have been improved and will generate far less exceptions on cookies now*
{{{
BasicRule wl:1005 "mz:$HEADERS_VAR:cookie" ;
BasicRule wl:1010 "mz:$HEADERS_VAR:cookie" ;
BasicRule wl:1011 "mz:$HEADERS_VAR:cookie" ;
BasicRule wl:1308 "mz:$HEADERS_VAR:cookie" ;
BasicRule wl:1309 "mz:$HEADERS_VAR:cookie" ;
BasicRule wl:1315 "mz:$HEADERS_VAR:cookie" ;
}}}

And now, if I reload the home page of my company's website, the number of exception won't grow anymore. It means that the whitelists that were generated are accurate enough.

I will continue browsing though the website to see wether there is other false positives. Generally, most of the false positives will be triggered in the first two pages, because they are caused by funky URL rewritting, and the way your cookies are created.

== user forms ==

Now comes the "tricky" part of whitelists triggers : USER FORMS !

Yes, fields with 'free' user input, such as registration forms, search boxes and so on are typically parts that you should take a great care of.

For example, my company's website contains a "contact" form with lastname, firstname, email adress, and a free text zone. I arbitrary decided that I will allow simple/double quotes as well as coma and semi-coma in the last/first names fields, and included as well parenthesis for the free text zone. So, I will simply fill the form and HttpConfigPy will generate the associated whitelists.

Once I've filled the forms, if I look at my HttpConfigPy interface, I will see that new exceptions have been generated :
{{{
You currently have 40.0 rules generated by naxsi.
You should reload nginx's config WRITE AND RELOAD
You have a total of 138.0 exceptions hit.
}}}

Let's reload it, and have a look at the generated whitelists !
New rules have been generated, in the style :
{{{
BasicRule wl:1001 "mz:$BODY_VAR:cf4_field_1" ;
BasicRule wl:1008 "mz:$BODY_VAR:cf4_field_1" ;
BasicRule wl:1013 "mz:$BODY_VAR:cf4_field_1" ;
BasicRule wl:1014 "mz:$BODY_VAR:cf4_field_1" ;
BasicRule wl:1015 "mz:$BODY_VAR:cf4_field_1" ;
BasicRule wl:1306 "mz:$BODY_VAR:cf4_field_1" ;
BasicRule wl:1307 "mz:$BODY_VAR:cf4_field_1" ;
BasicRule wl:1313 "mz:$BODY_VAR:cf4_field_1" ;
BasicRule wl:1001 "mz:$BODY_VAR:cf4_field_2" ;
BasicRule wl:1008 "mz:$BODY_VAR:cf4_field_2" ;
BasicRule wl:1013 "mz:$BODY_VAR:cf4_field_2" ;
BasicRule wl:1014 "mz:$BODY_VAR:cf4_field_2" ;
BasicRule wl:1015 "mz:$BODY_VAR:cf4_field_2" ;
BasicRule wl:1306 "mz:$BODY_VAR:cf4_field_2" ;
BasicRule wl:1307 "mz:$BODY_VAR:cf4_field_2" ;
...
}}}

Once I've did the same for the searchbox, my configuration is now over, and we can browse the site, and fill the forms without generating any new exception !

== Some side notes ==

Sometimes, you will want to partially disable naxsi for a part of the website. In the case of my company's website, I don't want to configure / enable naxsi for the wordpress back-office, as it's already protected by a .htaccess.

Then, you can "simply" define another location, where you don't enable NAXSI :

{{{
location / {
     include    /etc/nginx/sec-rules/nbs.rules;
     proxy_pass http://194.213.124.111/;
     proxy_set_header Host www.nbs-system.com;
   }

location /wp-admin {
     proxy_pass https://194.213.124.111/;
     proxy_set_header Host www.nbs-system.com;
 }
}}}

And the trick is done ;)

Actually, you can do something way smarter. As wordpress is affected by numerous vulnerabilities in the back-office, I still want to protect it, but without spending too much time on the configuration, so here is what I'm doing :

{{{
location /wp-admin {
         include /etc/nginx/sec-rules/nbs.rules;
         BasicRule wl:0 mz:BODY;
         proxy_pass https://194.213.124.111;
         proxy_set_header Host www.nbs-system.com;
}
}}}

I'm enabling NAXSI, but I'm disabling all checks on BODY, as it's the painfull part (posting HTML and so on). In this way, I will still protect WP back-office from vulnerabilities that are exploited through GET requests.